---
layout: post
title: "Exploiting the eques elf smart plug: Part three"
date: 2019-08-27 15:53:09 +0300
comments: true
categories: [radio, iot]
---
In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let's concentrate on that in this post.

<!--more-->

We currently can:

* Decrypt messages between the phone, smart plug and server during plug discovery and port 9123 communication.
* Discover any smart plug in the network and its details.
* Communicate with ikonkek2.com server and query various details about a smart plug.

We cannot:

* Remotely control the smart plug – Turn it on or off.

# Part two: More secret keys, hooks and a debugger

Turning the smart plug on or off happens over an xmpp chat (port 5222). The phone uses the username <span style="color:red">"phone mac"eques@ikonkenk2.com</span> while the username of the smart plug is <span style="color:red">"device mac"@ikonkek2.com</span>.

The messages exchanged look like this:

```bash
"encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsN
EwNWwDj1OYLY=
```

---

Let’s continue our analysis the dynamic way. Let’s start by using Android’s logging capability - logcat.

When we turn the plug on, this is what we observe on logcat:

{% img /images/relayopen.png %}

Clearer output:

```bash
E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%f7HTEgDfZPLCyOqB4b2XZA==%relay to dc-4f-22-25-xx-xx@ikonkek2.com
```
And
```bash
E ==Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@bba1c8b=======wan_device%dc-4f-22-25-xx-xx%nopassword%open%1563100747%rack
```
---
When we turn the plug off

{% img /images/relayclose.png %}

Clearer output:

```bash
XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%1F6E1GyngNXKROGzGOmB4g==%relay to dc-4f-22-25-xx-xx@ikonkek2.com
```
And
```bash
E ==Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@35ef906=======wan_device%dc-4f-22-25-xx-xx%nopassword%close%1563100818%rack
```
---

We note that the function <span style="color:red">sendEncodeMessage</span> is called when sending the XMPP message.

Let’s understand the process through dynamic analysis with Frida and GDB.

We start by running our frida-server on the phone, attach to the app and trace the “open” function:

<span style="color:green">frida-trace -i "open" -U -f "com.eques.plug"</span>

We can see the app’s db is located at **/data/user/0/com.eques.plug/databases/afinal.db**

{% img /images/db.png %}

We can extract the db and open it with sqlitebrowser and see what is stored:

{% img /images/ikonke_device.png %}

From the frida output we can also see the native library <span style="color:blue">libKonkeEncrypt.so</span> being opened when we turn the plug on or off.

{% img /images/konkeopen.png %}

---

To give us more control we’ll use the frida's scripting capability and its python bindings.

We can start by writing a script that prints out all the arguments and return values when the <span style="color:red">sendEncodeMessage</span> function we discovered is called.

When we turn on the plug:

{% img /images/sendEncode_open.png %}

When we turn off the plug:

{% img /images/sendEncode_close.png %}

The output looks like what we had seen earlier on logcat with the word open or close replaced with some encrypted/encoded data.

Logcat message we had seen:

> E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<span style="color:red">f7HTEgDfZPLCyOqB4b2XZA==</span>%relay to dc-4f-22-25-xx-xx@ikonkek2.com

What we see from hooking the SendEncodeMessage() function:

> wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<span style="color:red">open</span>%relay

It looks like at some point, the words open (when turning on the plug) and close (when turning off the plug), have some encryption/encoding done to them.

---

So let’s go back to the reversed apk and figure out what happens. What we discover is that a timestamp is inserted into the message then some encryption/encoding done.

This is done by the function <span style="color:red">insertTimestampIntoMessage</span>

{% img /images/timestamp.png %}

Let’s write another frida script to intercept and log this function:

{% img /images/sendEncode_timestamp.png %}

We can now confirm that indeed this is where the additional encryption/encoding is done. Also note **arg3** is set to true.

If we again look at the <span style="color:red">insertTimestampIntoMessage</span> function Arg3 refers to the boolean value **needNewEncode**. When **needNewEncode** is set to true, the following operation is done:

<span style="color:green">cmd = EncryptUtil.newEncode(cmd.substring(1), deviceModel);</span> 

Let’s write another frida script to hook the <span style="color:red">newEncode()</span> function.

{% img /images/newEncode.png %}

Here we see a timestamp is added to the word open and an encrypted/encoded result returned.

---

Back to the reversed apk code we can see that <span style="color:red">newEncode()</span> uses <span style="color:red">KonkeEncrypt().encryptCmdString</span> to encrypt the command:

{% img /images/encryptcmdstring.png %}

Let’s write one more frida script to hook the <span style="color:red">encryptCmdString() </span> function:

{% img /images/konke_encrypt.png %}

This confirms, we're in the right path.

From there we discover that the function is loaded from a native library called <span style="color:blue">KonkeEncrypt</span>:

{% img /images/konkeencrypt.png %}

The library is packaged with the apk in the **lib/armeabi** folder:

{% img /images/libKonke.png %}

---

Let's head back to Ghidra to see if we can figure out what exactly is happening during this encryption/encoding process.

The steps are basically the same as before:

We will open the <span style="color:blue">libKonkeEncrypt.so</span> file in Ghidra and then look for the <span style="color:red">encryptCmdString()</span> function.

{% img /images/encryptcmdghidra.png %}


We can get an idea of the flow from the function call graph:

{% img /images/encryptcmd_flow.png %}

---

Let’s see if we can see the library in action. For this we’re going to debug the <span style="color:red">libKonkeEncrypt.so</span> library using GEF (https://github.com/hugsy/gef) – An enhanced version of GDB.

First we’re going  to copy an arm gdbserver to the phone in the **/data/local/tmp/** directory.

From an adb shell, we then start the gdbserver:

```bash
/data/local/tmp/gdbserver :1337 --attach $(ps | grep com.eques.plug | awk '{print $2}')
```

Then we forward the remote port to our host using adb:

```bash
adb forward tcp:1337 tcp:1337
```

Then we start GEF for remote debugging:

```bash
gef-remote :1337
```
GEF first reads symbols from the phone’s libraries:

{% img /images/gef-remote.png %}

Once that is done, we let the app continue running:

{% img /images/gef-connected.png %}

When we turn the plug on or off from the app, we can see the <span style="color:blue">libKonkeEncrypt.so</span> library gets opened by the app:

{% img /images/gef-konke.png %}

By running the <span style="color:blue">info functions</span> gef command we can see the functions in our library of interest:

{% img /images/gef-konke-functions.png %}

---

From our earlier ghidra analysis, <span style="color:red">aes_set_key()</span> sets the final encryption key in hex which is then used by <span style="color:red">EncryptData256()</span> to encrypt the command. Let’s set breakpoints at these two function's addresses and then continue running the app:

{% img /images/gef-breaks.png %}

When we hit the <span style="color:red">EncryptData256()</span> break point we can inspect the registers, stack and function trace:

<span style="color:blue">Registers</span>:

{% img /images/gef-encrypt-registers.png %}

<span style="color:blue">Stack</span>:

{% img /images/gef-encrypt-stack.png %}

<span style="color:blue">Function Trace</span>:

{% img /images/gef-encrypt-trace.png %}

---

We do the same when we hit the <span style="color:red">aes_set_key()</span> breakpoint:

<span style="color:blue">Registers</span>:

{% img /images/gef-aes-registers.png %}

<span style="color:blue">Stack</span>:

{% img /images/gef-aes-stack.png %}

<span style="color:blue">Function Trace</span>:

{% img /images/gef-aes-trace.png %}

Stepping through the execution flow till the end, we eventually get our key stored in the r1 register:

{% img /images/gef-aes-r1.png %}

The key is: <span style="color:green">1c2f36737d07617a538f9f66659a2623</span>.

---

We can convert it to hex and test it on some of our previously captured encrypted commands and confirm it is indeed the key:

{% img /images/konke_key_test.png %}

And it works!

---

Almost there, but not quite yet.

I tested the key against encrypted commands from other plugs, unfortunately it only worked for that one specific smart plug. We therefore need to figure out how the specific key for each smart power plug is generated.

After some more code analysis and debugging, the following is the function flow when <span style="color:red">encryptCmdString()</span> is called:

=> <span style="color:red">encryptCmdString()</span> calls <span style="color:red">EncryptData256()</span>

=>>>>> <span style="color:red">EncryptData256()</span> calls <span style="color:red">getKeyFromMethod2()</span>

=>>>>>>>>>>> <span style="color:red">getKeyFromMethod2()</span> calls <span style="color:red">cmd_string_parse()</span>

=>>>>>>>>>>> <span style="color:red">getKeyFromMethod2()</span> calls <span style="color:red">generateKey1FromString()</span>

=>>>>>>>>>>>>>>>>> <span style="color:red">generateKey1FromString()</span> calls <span style="color:red">generateKey2FromString()</span>

=>>>>>>>>>>> <span style="color:red">getKeyFromMethod2()</span> then calls <span style="color:red">dealKeyFromMethod2()</span>

=>>>>>>>>>>>>>>>>> <span style="color:red">dealKeyFromMethod2()</span> then returns the key

We are going to concentrate on the <span style="color:red">getKeyFromMethod2()</span> function.
First it calls <span style="color:red">cmd_string_parse()</span>. I spent a lot of time figuring out what it does, only to realise that all it does is remove the hyphens from the mac address with some fancy use of C pointers. So **dc-4f-22-25-xx-xx** would result in **dc4f2225xxxx**.

Next let’s move to <span style="color:red">generateKey1FromString()</span>. We can either go the static way using Ghidra or the dynamic way using GEF. Let's go with GEF.

We set breakpoints at <span style="color:red">generateKey1FromString()</span> and <span style="color:red">generateKey2FromString()</span> and then monitor the registers.

{% img /images/gef-remote-gen2.png %}

After some debugging we get what looks like a key: <span style="color:green">w5%45j!a,~j33in3lea^~rw2]ryxes8y</span> generated and stored in the r3 register.

With this discovery we can go back to Ghidra and continue analysing the <span style="color:red">getKeyFromMethod2()</span> function.

We notice that some manipulation is done on this key using the smart power plug's password:

{% img /images/keygen_devpass_or.png %}

What is happening is that the first 8 bytes of the key are bitwise OR’ed with the smart power plug's password. If the hex result of any of the bitwise ORs is 0x7e, it is replaced with 0x72. A quick python script can be written to reproduce this:

{% img /images/keygen_device_pass_script.png %}

The result is then passed on to <span style="color:red">dealKeyFromMethod2()</span> together with the parsed mac address (hyphens removed).

The return value is what should be our final key!

Analysing and cleaning up the code, I was able to figure out and reproduce the functionality.

The key has some of its bytes replaced with some bytes from the mac address of the smart power plug. This is done in the following manner:

* The 15th byte of the key is replaced with the 6th byte of the mac address
* The 16th byte of the key is replaced with the 7th byte of the mac address
* The 19th byte of the key is replaced with the 8th byte of the mac address
* The 20th byte of the key is replaced with the 9th byte of the mac address
* The 21st byte of the key is replaced with the 10th byte of the mac address
* The 22nd byte of the key is replaced with the 11th byte of the mac address

The md5sum is then calculated to create the final key.

---

In summary, this is how the smart power plug specific key is generated:

* <span style="color:red">cmd_string_parse()</span> removes hyphens from the mac address.
* <span style="color:red">generateKey1FromString()</span> and <span style="color:red">generateKey2FromString()</span> are used to produce the key: <span style="color:green">w5%45j!a,~j33in3lea^~rw2]ryxes8y</span>.
* <span style="color:red">getKeyFromMethod2()</span> bitwise ORs the first 8 bytes of the key with the device
name/password.
* <span style="color:red">dealKeyFromMethod2()</span> replaces some bytes of the key with some bytes of the mac
address, the md5sum of the result is the final device specific key.

I tested this against more than one smart power plug with successful decryptions.

Now we have all we need to control any plug:

* The smart power plug’s mac address
* The smart power plug’s password
* The two encryption keys (one device specific and the other common to all smart power plugs)

---

With these details, we can use an xmpp client like pidgin to connect to the xmpp server (ikonkek2.com) using the username <span style="color:blue">"phone macaddress"eques@ikonkek2.com</span>.

Next we generate the smart plug specific encryption key.

We then use this key to encrypt either the <span style="color:blue">open"timestamp"</span> or <span style="color:blue">close"timestamp"</span> part of our command.

Finally we encrypt the full message using the common encryption key.

We will add the prefix **encryption:** to our encrypted message and send it to the device’s username <span style="color:blue">"device macaddress@ikonkek2.com"</span> over xmpp.

Note: The xmpp’s user passwords are just the same as the usernames.

---

I automated the whole process of key generation, message formatting and encryption to output the message to be sent:

{% img /images/xmpp_commands.png %}

Next I just copy the message and send it using pidgin:

{% img /images/xmpp_control.png %}

And there we have it! We can now control the plug remotely even when it’s behind a NAT network.

The frida scripts and exploit code can be found <a href="https://github.com/iamckn/eques" target="_blank">**here.**</a>

---

In the final part, we will explore how this can be abused on a mass scale.