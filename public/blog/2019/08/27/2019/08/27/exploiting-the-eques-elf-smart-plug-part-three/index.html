<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Exploiting the Eques Elf Smart Plug Part Three - The poetry of (in)security</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Exploiting the Eques Elf Smart Plug Part Three" />
<meta property="og:description" content="In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blog/2019/08/27/2019/08/27/exploiting-the-eques-elf-smart-plug-part-three/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-27T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Exploiting the Eques Elf Smart Plug Part Three"/>
<meta name="twitter:description" content="In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post."/>

        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">The poetry of (in)security</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Exploiting the Eques Elf Smart Plug Part Three</h1>
          <div class="meta">Posted on Aug 27, 2019</div>
        </div>
        
        <section class="body">
          <p>In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post.</p>
<p>We currently can:</p>
<ul>
<li>Decrypt messages between the phone, smart plug and server during plug discovery and port 9123 communication.</li>
<li>Discover any smart plug in the network and its details.</li>
<li>Communicate with ikonkek2.com server and query various details about a smart plug.</li>
</ul>
<p>We cannot:</p>
<ul>
<li>Remotely control the smart plug – Turn it on or off.</li>
</ul>
<h1 id="part-two-more-secret-keys-hooks-and-a-debugger">Part two: More secret keys, hooks and a debugger</h1>
<p>Turning the smart plug on or off happens over an xmpp chat (port 5222). The phone uses the username <!-- raw HTML omitted -->&ldquo;phone mac&quot;eques@ikonkenk2.com<!-- raw HTML omitted --> while the username of the smart plug is <!-- raw HTML omitted -->&ldquo;device mac&rdquo;@ikonkek2.com<!-- raw HTML omitted -->.</p>
<p>The messages exchanged look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#e6db74">&#34;encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsN
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EwNWwDj1OYLY=
</span></span></span></code></pre></div><p>+++</p>
<p>Let’s continue our analysis the dynamic way. Let’s start by using Android’s logging capability - logcat.</p>
<p>When we turn the plug on, this is what we observe on logcat:</p>
<p>{% img /images/relayopen.png %}</p>
<p>Clearer output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%f7HTEgDfZPLCyOqB4b2XZA<span style="color:#f92672">==</span>%relay to dc-4f-22-25-xx-xx@ikonkek2.com
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">==</span>Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@bba1c8b<span style="color:#f92672">=======</span>wan_device%dc-4f-22-25-xx-xx%nopassword%open%1563100747%rack
</span></span></code></pre></div><p>+++
When we turn the plug off</p>
<p>{% img /images/relayclose.png %}</p>
<p>Clearer output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%1F6E1GyngNXKROGzGOmB4g<span style="color:#f92672">==</span>%relay to dc-4f-22-25-xx-xx@ikonkek2.com
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">==</span>Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@35ef906<span style="color:#f92672">=======</span>wan_device%dc-4f-22-25-xx-xx%nopassword%close%1563100818%rack
</span></span></code></pre></div><p>+++</p>
<p>We note that the function <!-- raw HTML omitted -->sendEncodeMessage<!-- raw HTML omitted --> is called when sending the XMPP message.</p>
<p>Let’s understand the process through dynamic analysis with Frida and GDB.</p>
<p>We start by running our frida-server on the phone, attach to the app and trace the “open” function:</p>
<p><!-- raw HTML omitted -->frida-trace -i &ldquo;open&rdquo; -U -f &ldquo;com.eques.plug&rdquo;<!-- raw HTML omitted --></p>
<p>We can see the app’s db is located at <strong>/data/user/0/com.eques.plug/databases/afinal.db</strong></p>
<p>{% img /images/db.png %}</p>
<p>We can extract the db and open it with sqlitebrowser and see what is stored:</p>
<p>{% img /images/ikonke_device.png %}</p>
<p>From the frida output we can also see the native library <!-- raw HTML omitted -->libKonkeEncrypt.so<!-- raw HTML omitted --> being opened when we turn the plug on or off.</p>
<p>{% img /images/konkeopen.png %}</p>
<p>+++</p>
<p>To give us more control we’ll use the frida&rsquo;s scripting capability and its python bindings.</p>
<p>We can start by writing a script that prints out all the arguments and return values when the <!-- raw HTML omitted -->sendEncodeMessage<!-- raw HTML omitted --> function we discovered is called.</p>
<p>When we turn on the plug:</p>
<p>{% img /images/sendEncode_open.png %}</p>
<p>When we turn off the plug:</p>
<p>{% img /images/sendEncode_close.png %}</p>
<p>The output looks like what we had seen earlier on logcat with the word open or close replaced with some encrypted/encoded data.</p>
<p>Logcat message we had seen:</p>
<blockquote>
<p>E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<!-- raw HTML omitted -->f7HTEgDfZPLCyOqB4b2XZA==<!-- raw HTML omitted -->%relay to <a href="mailto:dc-4f-22-25-xx-xx@ikonkek2.com">dc-4f-22-25-xx-xx@ikonkek2.com</a></p>
</blockquote>
<p>What we see from hooking the SendEncodeMessage() function:</p>
<blockquote>
<p>wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<!-- raw HTML omitted -->open<!-- raw HTML omitted -->%relay</p>
</blockquote>
<p>It looks like at some point, the words open (when turning on the plug) and close (when turning off the plug), have some encryption/encoding done to them.</p>
<p>+++</p>
<p>So let’s go back to the reversed apk and figure out what happens. What we discover is that a timestamp is inserted into the message then some encryption/encoding done.</p>
<p>This is done by the function <!-- raw HTML omitted -->insertTimestampIntoMessage<!-- raw HTML omitted --></p>
<p>{% img /images/timestamp.png %}</p>
<p>Let’s write another frida script to intercept and log this function:</p>
<p>{% img /images/sendEncode_timestamp.png %}</p>
<p>We can now confirm that indeed this is where the additional encryption/encoding is done. Also note <strong>arg3</strong> is set to true.</p>
<p>If we again look at the <!-- raw HTML omitted -->insertTimestampIntoMessage<!-- raw HTML omitted --> function Arg3 refers to the boolean value <strong>needNewEncode</strong>. When <strong>needNewEncode</strong> is set to true, the following operation is done:</p>
<p><!-- raw HTML omitted -->cmd = EncryptUtil.newEncode(cmd.substring(1), deviceModel);<!-- raw HTML omitted --></p>
<p>Let’s write another frida script to hook the <!-- raw HTML omitted -->newEncode()<!-- raw HTML omitted --> function.</p>
<p>{% img /images/newEncode.png %}</p>
<p>Here we see a timestamp is added to the word open and an encrypted/encoded result returned.</p>
<p>+++</p>
<p>Back to the reversed apk code we can see that <!-- raw HTML omitted -->newEncode()<!-- raw HTML omitted --> uses <!-- raw HTML omitted -->KonkeEncrypt().encryptCmdString<!-- raw HTML omitted --> to encrypt the command:</p>
<p>{% img /images/encryptcmdstring.png %}</p>
<p>Let’s write one more frida script to hook the <!-- raw HTML omitted -->encryptCmdString() <!-- raw HTML omitted --> function:</p>
<p>{% img /images/konke_encrypt.png %}</p>
<p>This confirms, we&rsquo;re in the right path.</p>
<p>From there we discover that the function is loaded from a native library called <!-- raw HTML omitted -->KonkeEncrypt<!-- raw HTML omitted -->:</p>
<p>{% img /images/konkeencrypt.png %}</p>
<p>The library is packaged with the apk in the <strong>lib/armeabi</strong> folder:</p>
<p>{% img /images/libKonke.png %}</p>
<p>+++</p>
<p>Let&rsquo;s head back to Ghidra to see if we can figure out what exactly is happening during this encryption/encoding process.</p>
<p>The steps are basically the same as before:</p>
<p>We will open the <!-- raw HTML omitted -->libKonkeEncrypt.so<!-- raw HTML omitted --> file in Ghidra and then look for the <!-- raw HTML omitted -->encryptCmdString()<!-- raw HTML omitted --> function.</p>
<p>{% img /images/encryptcmdghidra.png %}</p>
<p>We can get an idea of the flow from the function call graph:</p>
<p>{% img /images/encryptcmd_flow.png %}</p>
<p>+++</p>
<p>Let’s see if we can see the library in action. For this we’re going to debug the <!-- raw HTML omitted -->libKonkeEncrypt.so<!-- raw HTML omitted --> library using GEF (<a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a>) – An enhanced version of GDB.</p>
<p>First we’re going  to copy an arm gdbserver to the phone in the <strong>/data/local/tmp/</strong> directory.</p>
<p>From an adb shell, we then start the gdbserver:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/data/local/tmp/gdbserver :1337 --attach <span style="color:#66d9ef">$(</span>ps | grep com.eques.plug | awk <span style="color:#e6db74">&#39;{print $2}&#39;</span><span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>Then we forward the remote port to our host using adb:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>adb forward tcp:1337 tcp:1337
</span></span></code></pre></div><p>Then we start GEF for remote debugging:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef-remote :1337
</span></span></code></pre></div><p>GEF first reads symbols from the phone’s libraries:</p>
<p>{% img /images/gef-remote.png %}</p>
<p>Once that is done, we let the app continue running:</p>
<p>{% img /images/gef-connected.png %}</p>
<p>When we turn the plug on or off from the app, we can see the <!-- raw HTML omitted -->libKonkeEncrypt.so<!-- raw HTML omitted --> library gets opened by the app:</p>
<p>{% img /images/gef-konke.png %}</p>
<p>By running the <!-- raw HTML omitted -->info functions<!-- raw HTML omitted --> gef command we can see the functions in our library of interest:</p>
<p>{% img /images/gef-konke-functions.png %}</p>
<p>+++</p>
<p>From our earlier ghidra analysis, <!-- raw HTML omitted -->aes_set_key()<!-- raw HTML omitted --> sets the final encryption key in hex which is then used by <!-- raw HTML omitted -->EncryptData256()<!-- raw HTML omitted --> to encrypt the command. Let’s set breakpoints at these two function&rsquo;s addresses and then continue running the app:</p>
<p>{% img /images/gef-breaks.png %}</p>
<p>When we hit the <!-- raw HTML omitted -->EncryptData256()<!-- raw HTML omitted --> break point we can inspect the registers, stack and function trace:</p>
<p><!-- raw HTML omitted -->Registers<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-encrypt-registers.png %}</p>
<p><!-- raw HTML omitted -->Stack<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-encrypt-stack.png %}</p>
<p><!-- raw HTML omitted -->Function Trace<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-encrypt-trace.png %}</p>
<p>+++</p>
<p>We do the same when we hit the <!-- raw HTML omitted -->aes_set_key()<!-- raw HTML omitted --> breakpoint:</p>
<p><!-- raw HTML omitted -->Registers<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-aes-registers.png %}</p>
<p><!-- raw HTML omitted -->Stack<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-aes-stack.png %}</p>
<p><!-- raw HTML omitted -->Function Trace<!-- raw HTML omitted -->:</p>
<p>{% img /images/gef-aes-trace.png %}</p>
<p>Stepping through the execution flow till the end, we eventually get our key stored in the r1 register:</p>
<p>{% img /images/gef-aes-r1.png %}</p>
<p>The key is: <!-- raw HTML omitted -->1c2f36737d07617a538f9f66659a2623<!-- raw HTML omitted -->.</p>
<p>+++</p>
<p>We can convert it to hex and test it on some of our previously captured encrypted commands and confirm it is indeed the key:</p>
<p>{% img /images/konke_key_test.png %}</p>
<p>And it works!</p>
<p>+++</p>
<p>Almost there, but not quite yet.</p>
<p>I tested the key against encrypted commands from other plugs, unfortunately it only worked for that one specific smart plug. We therefore need to figure out how the specific key for each smart power plug is generated.</p>
<p>After some more code analysis and debugging, the following is the function flow when <!-- raw HTML omitted -->encryptCmdString()<!-- raw HTML omitted --> is called:</p>
<p>=&gt; <!-- raw HTML omitted -->encryptCmdString()<!-- raw HTML omitted --> calls <!-- raw HTML omitted -->EncryptData256()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&gt; <!-- raw HTML omitted -->EncryptData256()<!-- raw HTML omitted --> calls <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&raquo;&raquo;&raquo;&gt; <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> calls <!-- raw HTML omitted -->cmd_string_parse()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&raquo;&raquo;&raquo;&gt; <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> calls <!-- raw HTML omitted -->generateKey1FromString()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&gt; <!-- raw HTML omitted -->generateKey1FromString()<!-- raw HTML omitted --> calls <!-- raw HTML omitted -->generateKey2FromString()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&raquo;&raquo;&raquo;&gt; <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> then calls <!-- raw HTML omitted -->dealKeyFromMethod2()<!-- raw HTML omitted --></p>
<p>=&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&raquo;&gt; <!-- raw HTML omitted -->dealKeyFromMethod2()<!-- raw HTML omitted --> then returns the key</p>
<p>We are going to concentrate on the <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> function.
First it calls <!-- raw HTML omitted -->cmd_string_parse()<!-- raw HTML omitted -->. I spent a lot of time figuring out what it does, only to realise that all it does is remove the hyphens from the mac address with some fancy use of C pointers. So <strong>dc-4f-22-25-xx-xx</strong> would result in <strong>dc4f2225xxxx</strong>.</p>
<p>Next let’s move to <!-- raw HTML omitted -->generateKey1FromString()<!-- raw HTML omitted -->. We can either go the static way using Ghidra or the dynamic way using GEF. Let&rsquo;s go with GEF.</p>
<p>We set breakpoints at <!-- raw HTML omitted -->generateKey1FromString()<!-- raw HTML omitted --> and <!-- raw HTML omitted -->generateKey2FromString()<!-- raw HTML omitted --> and then monitor the registers.</p>
<p>{% img /images/gef-remote-gen2.png %}</p>
<p>After some debugging we get what looks like a key: <!-- raw HTML omitted -->w5%45j!a,~j33in3lea^~rw2]ryxes8y<!-- raw HTML omitted --> generated and stored in the r3 register.</p>
<p>With this discovery we can go back to Ghidra and continue analysing the <!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> function.</p>
<p>We notice that some manipulation is done on this key using the smart power plug&rsquo;s password:</p>
<p>{% img /images/keygen_devpass_or.png %}</p>
<p>What is happening is that the first 8 bytes of the key are bitwise OR’ed with the smart power plug&rsquo;s password. If the hex result of any of the bitwise ORs is 0x7e, it is replaced with 0x72. A quick python script can be written to reproduce this:</p>
<p>{% img /images/keygen_device_pass_script.png %}</p>
<p>The result is then passed on to <!-- raw HTML omitted -->dealKeyFromMethod2()<!-- raw HTML omitted --> together with the parsed mac address (hyphens removed).</p>
<p>The return value is what should be our final key!</p>
<p>Analysing and cleaning up the code, I was able to figure out and reproduce the functionality.</p>
<p>The key has some of its bytes replaced with some bytes from the mac address of the smart power plug. This is done in the following manner:</p>
<ul>
<li>The 15th byte of the key is replaced with the 6th byte of the mac address</li>
<li>The 16th byte of the key is replaced with the 7th byte of the mac address</li>
<li>The 19th byte of the key is replaced with the 8th byte of the mac address</li>
<li>The 20th byte of the key is replaced with the 9th byte of the mac address</li>
<li>The 21st byte of the key is replaced with the 10th byte of the mac address</li>
<li>The 22nd byte of the key is replaced with the 11th byte of the mac address</li>
</ul>
<p>The md5sum is then calculated to create the final key.</p>
<p>+++</p>
<p>In summary, this is how the smart power plug specific key is generated:</p>
<ul>
<li><!-- raw HTML omitted -->cmd_string_parse()<!-- raw HTML omitted --> removes hyphens from the mac address.</li>
<li><!-- raw HTML omitted -->generateKey1FromString()<!-- raw HTML omitted --> and <!-- raw HTML omitted -->generateKey2FromString()<!-- raw HTML omitted --> are used to produce the key: <!-- raw HTML omitted -->w5%45j!a,~j33in3lea^~rw2]ryxes8y<!-- raw HTML omitted -->.</li>
<li><!-- raw HTML omitted -->getKeyFromMethod2()<!-- raw HTML omitted --> bitwise ORs the first 8 bytes of the key with the device
name/password.</li>
<li><!-- raw HTML omitted -->dealKeyFromMethod2()<!-- raw HTML omitted --> replaces some bytes of the key with some bytes of the mac
address, the md5sum of the result is the final device specific key.</li>
</ul>
<p>I tested this against more than one smart power plug with successful decryptions.</p>
<p>Now we have all we need to control any plug:</p>
<ul>
<li>The smart power plug’s mac address</li>
<li>The smart power plug’s password</li>
<li>The two encryption keys (one device specific and the other common to all smart power plugs)</li>
</ul>
<p>+++</p>
<p>With these details, we can use an xmpp client like pidgin to connect to the xmpp server (ikonkek2.com) using the username <!-- raw HTML omitted -->&ldquo;phone macaddress&quot;eques@ikonkek2.com<!-- raw HTML omitted -->.</p>
<p>Next we generate the smart plug specific encryption key.</p>
<p>We then use this key to encrypt either the <!-- raw HTML omitted -->open&quot;timestamp&rdquo;<!-- raw HTML omitted --> or <!-- raw HTML omitted -->close&quot;timestamp&rdquo;<!-- raw HTML omitted --> part of our command.</p>
<p>Finally we encrypt the full message using the common encryption key.</p>
<p>We will add the prefix <strong>encryption:</strong> to our encrypted message and send it to the device’s username <!-- raw HTML omitted -->&ldquo;device <a href="mailto:macaddress@ikonkek2.com">macaddress@ikonkek2.com</a>&rdquo;<!-- raw HTML omitted --> over xmpp.</p>
<p>Note: The xmpp’s user passwords are just the same as the usernames.</p>
<p>+++</p>
<p>I automated the whole process of key generation, message formatting and encryption to output the message to be sent:</p>
<p>{% img /images/xmpp_commands.png %}</p>
<p>Next I just copy the message and send it using pidgin:</p>
<p>{% img /images/xmpp_control.png %}</p>
<p>And there we have it! We can now control the plug remotely even when it’s behind a NAT network.</p>
<p>The frida scripts and exploit code can be found <!-- raw HTML omitted --><strong>here.</strong><!-- raw HTML omitted --></p>
<p>+++</p>
<p>In the final part, we will explore how this can be abused on a mass scale.</p>
        </section>
        <div class="post-tags">
          
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/iamckn" rel="me" title="GitHub"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a><a class="border"></a><a class="soc" href="https://twitter.com/iamckn/" rel="me" title="Twitter"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#twitter" />
</svg></a><a class="border"></a></div>
  <div class="footer-info">
    2025  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
