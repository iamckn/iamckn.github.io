<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Exploiting the eques elf smart plug: Part two - The poetry of (in)security</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In part one, we concentrated on analysing the network communication when one turns the smart power plug on or off from the app.
We had noticed some form of encrypted/encoded communication happening on udp port 27431 between the smart plug and the app installed on the phone. We also noticed some form of encrypted/encoded communication on tcp ports 9123 and 5222(xmpp) between the app, smart plug and ikonkek2.com." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Exploiting the eques elf smart plug: Part two" />
<meta property="og:description" content="In part one, we concentrated on analysing the network communication when one turns the smart power plug on or off from the app.
We had noticed some form of encrypted/encoded communication happening on udp port 27431 between the smart plug and the app installed on the phone. We also noticed some form of encrypted/encoded communication on tcp ports 9123 and 5222(xmpp) between the app, smart plug and ikonkek2.com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blog/2019-08-25-exploiting-the-eques-elf-smart-plug-part-two/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2019-08-27T14:23:39+03:00" />
<meta property="article:modified_time" content="2019-08-27T14:23:39+03:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Exploiting the eques elf smart plug: Part two"/>
<meta name="twitter:description" content="In part one, we concentrated on analysing the network communication when one turns the smart power plug on or off from the app.
We had noticed some form of encrypted/encoded communication happening on udp port 27431 between the smart plug and the app installed on the phone. We also noticed some form of encrypted/encoded communication on tcp ports 9123 and 5222(xmpp) between the app, smart plug and ikonkek2.com."/>

        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">The poetry of (in)security</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Exploiting the eques elf smart plug: Part two</h1>
          <div class="meta">Posted on Aug 27, 2019</div>
        </div>
        
        <section class="body">
          <p>In part one, we concentrated on analysing the network communication when one turns the smart power plug on or off from the app.
We had noticed some form of encrypted/encoded communication happening on udp port 27431 between the smart plug and the app installed on the phone. We also noticed some form of encrypted/encoded communication on tcp ports 9123 and 5222(xmpp) between the app, smart plug and ikonkek2.com.</p>
<h1 id="part-two-not-so-secret-keys-some-assembly-and-a-reverse-engineer">Part two: Not so secret keys, some assembly and a reverse engineer</h1>
<p>Let’s reverse the apk to see if the code can tell us what type of encryption/encoding was happening.
I have a preference for <!-- raw HTML omitted --><strong>jadx-gui</strong><!-- raw HTML omitted --> so that’s what I used.</p>
<p>First let’s search for the domains we had seen in the network traffic.
Searching for ikonke.us reveals the firmware download url. Note that it is http. This is under the <!-- raw HTML omitted -->UpdateFirmwareUtil<!-- raw HTML omitted --> class. About 15 different downloads are listed indicating the app supports multiple devices.</p>
<p>{% img /images/firmware_url.png %}</p>
<p>We can also see various variables are mapped to their values in the <!-- raw HTML omitted -->com.kankunit.smartknorns.commonutil.CommonMap<!-- raw HTML omitted --> file.</p>
<p>{% img /images/commonmap.png %}</p>
<p>This collaborates our earlier network traffic analysis related to port 9123 and XMPP(5222).
We can now also conclude that ikonkek2.com hosts an Apache Mina server listening on ports 9123 and 50003, and an XMPP server listening on port 5222.</p>
<hr>
<p>We had earlier discovered that the app tries to discover the plug by sending some broadcast messages on port 27431. Let’s see if we can figure out what the exact messages are from the app.</p>
<p>Searching for this in the code reveals the class <!-- raw HTML omitted -->com.kankunit.smartknorns.service.BaseUdpBroadcastService<!-- raw HTML omitted -->.</p>
<p>{% img /images/udp_broadcast.png %}</p>
<p>The command sent is:</p>
<p><!-- raw HTML omitted -->lan_phone%mac%nopassword%&quot; + new SimpleDateFormat(DateTransformer.DATE_FORMAT,
Locale.ENGLISH).format(new Date(System.currentTimeMillis())) + &ldquo;%heart<!-- raw HTML omitted --></p>
<p>The sending method is <!-- raw HTML omitted -->PackageSendData<!-- raw HTML omitted -->:</p>
<p><!-- raw HTML omitted -->byte[] cmd_buf = BaseUdpBroadcastService.this.sj.PackageSendData(cmd, cmd.length());<!-- raw HTML omitted --></p>
<p>This method is from the class <!-- raw HTML omitted -->smartplug.JniC<!-- raw HTML omitted --></p>
<p>{% img /images/PackageSendData.png %}</p>
<p>The method is called from the native library <!-- raw HTML omitted -->CommunSmartPlug-jni<!-- raw HTML omitted -->.</p>
<p>The library is packaged with the app in the <strong>lib/armeabi</strong> folder</p>
<p>{% img /images/libs.png %}</p>
<p>We can access the file by unzipping the apk and navigating to the <strong>lib/armeabi</strong> folder.</p>
<p>Running the file command on it reveals it is a 32-bit ARM binary:</p>
<p>{% img /images/file_libComm.png %}</p>
<p>We can also run strings on it to gather more information. Sample output reveals we’re on the right path as we can see the string  <!-- raw HTML omitted -->PackageSendData<!-- raw HTML omitted --> as part of the output.</p>
<p>{% img /images/strings_libComm.png %}</p>
<hr>
<p>Time for Ghidra!</p>
<p>We open the native library in Ghidra and start by looking at the Symbol Tree to locate our function:</p>
<p>{% img /images/ghidra_symbols.png %}</p>
<p>Displaying the call graph, we note it calls the function <!-- raw HTML omitted -->EncryptData256<!-- raw HTML omitted -->, which in turn calls the functions <!-- raw HTML omitted -->aes_set_key<!-- raw HTML omitted --> and <!-- raw HTML omitted -->aes_encrypt<!-- raw HTML omitted -->:</p>
<p>{% img /images/senddata_call.png %}</p>
<p>Let’s start by analysing the <!-- raw HTML omitted -->EncryptData256<!-- raw HTML omitted --> function:</p>
<p><em>Before analysis</em></p>
<p>{% img /images/encrypt_raw.png %}</p>
<p><em>After analysis and some cleanup</em></p>
<p>{% img /images/encrypt_analysed.png %}</p>
<p>After some more analysis and cleaning up the code, we get to the following code snippet:</p>
<p>{% img /images/aes_key.png %}</p>
<p>We see the use of the the function <!-- raw HTML omitted -->get_key<!-- raw HTML omitted --> to fetch the aes key in bytes, the function <!-- raw HTML omitted -->aes_set_key<!-- raw HTML omitted --> then sets the encryption key in hex.</p>
<p>The key is then used to encrypt the plaintext as below:</p>
<p>{% img /images/aes_encrypt.png %}</p>
<p>So what we need to find out is what the aes key is, we start by figuring out what the <!-- raw HTML omitted -->get_key<!-- raw HTML omitted --> function does:</p>
<p>{% img /images/get_key.png %}</p>
<p>The function uses switch statements to set a character to each corresponding position in the key.</p>
<p>We can therefore reconstruct the key manually or by using Ghidra&rsquo;s scripting functionality.</p>
<p>The final key is: <!-- raw HTML omitted -->fdsl;mewrjope456fds4fbvfnjwaugfo<!-- raw HTML omitted --></p>
<p>Let’s confirm the key works!</p>
<hr>
<p>Remember the messages we’d seen being broadcast by the app on udp port 27431? Let’s try decrypt one.</p>
<p>We first convert our key to hex then try decrypting one of the UDP messages we had captured:</p>
<p>{% img /images/decryption_test.png %}</p>
<p>Eureka! The key works!</p>
<p>The decrypted command confirms the format of the UDP messages as earlier discovered:</p>
<p><!-- raw HTML omitted -->lan_phone%mac%nopassword%&rdquo; + new SimpleDateFormat(DateTransformer.DATE_FORMAT,
Locale.ENGLISH).format(new Date(System.currentTimeMillis())) + &ldquo;%heart<!-- raw HTML omitted --></p>
<hr>
<p>Let’s try our first attack - Discovering all smarts plug connected to a network and their details.</p>
<p>For this, we’re going to use go code to:</p>
<ul>
<li>Format the command and insert the current time as per the message specifications.</li>
<li>Encrypt the message with the key.</li>
<li>Send it to the broadcast address on UDP port 27431.</li>
<li>Listen for responses.</li>
<li>Decrypt the received messages.</li>
</ul>
<p>Once we run our custom discovery tool, we get responses from all the smart plugs in the network and various details such as IP, mac address, device name/password, status, hardware and software versions:</p>
<p>{% img /images/udp_plug_discovery.png %}</p>
<hr>
<p>We had also seen network communication between the app and the server (ikonkek2.com) on port 9123. Let’s try see if we can figure it out.</p>
<p>We can start with one of the first messages we saw:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>synchroFriends:QL+o4atMbQYvmyopU7DwqU3xXKYQt/MfZtNrDZlA4oayAvVY+XoCTChO1Q00I5lR
</span></span><span style="display:flex;"><span>VRbu1j85/S6EtkuzlSnsNQ<span style="color:#f92672">==</span>
</span></span></code></pre></div><p>We can look for this in our reversed apk:</p>
<p>{% img /images/synchro.png %}</p>
<p>What we see is that the <!-- raw HTML omitted -->minaEncode<!-- raw HTML omitted --> method base64 encodes the output from the <!-- raw HTML omitted -->PackageSendData<!-- raw HTML omitted --> method.</p>
<p>{% img /images/minaencode.png %}</p>
<p>This is the same method that is used to encrypt the UDP discovery messages. Good thing we already analysed that method and got the encryption key.</p>
<p>By further analysing the reversed apk we see that the message format takes the form of:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;cleartext description of the action&gt;:&lt;EncryptUtil.minaEncode<span style="color:#f92672">(</span>some message<span style="color:#f92672">)</span>&gt;
</span></span></code></pre></div><p>This is clearly visible in the following snippet:</p>
<p>{% img /images/mina_Encode.png %}</p>
<hr>
<h1 id="decryption-test">Decryption test</h1>
<p>Let’s try decryption of some of the messages we had captured in the network traffic.</p>
<p>Get device information</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>getDeviceInfo:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2fx7gFo+8WXHSEERZkoj0cI2kuhoJz/TMH4cOF0cH5luA<span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReeeuO61tEz+9XcaNZwJo3o7aPMxgJwsDDgFcH+HDwChklPvnRC5bPqrpHzLyZK9g0<span style="color:#f92672">=</span>
</span></span></code></pre></div><p>{% img /images/getDeviceInfo.png %}</p>
<hr>
<p>Get device status</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>getDeviceStatus:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2eOvkUKU+0kgmaR7hkY2JLP
</span></span><span style="display:flex;"><span>hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReUX1M+EvqrQUuw1Ag/eSc0
</span></span></code></pre></div><p>{% img /images/getdevicestatus.png %}</p>
<hr>
<h1 id="running-remote-commands">Running remote commands</h1>
<p>Let’s try exploit this feature to perform remote query of various details about the smart plug from the ikonkek2.com server. We can do this from anywhere as long as we have an internet connection.</p>
<p>We are again going to write some go code to:</p>
<ul>
<li>Create commands and format the messages.</li>
<li>Encrypt the messages with the key.</li>
<li>Send the messages to ikonkek2.com on port 9123.</li>
<li>Listen for responses.</li>
<li>Decrypt the received messages.</li>
</ul>
<p>All we need is the mac address of a smart plug</p>
<p>Get device information:</p>
<p>{% img /images/deviceinfodemo.png %}</p>
<hr>
<p>Get device status:</p>
<p>{% img /images/devicestatusdemo.png %}</p>
<hr>
<p>Get email linked to the device:</p>
<p>{% img /images/deviceemailinfo.png %}</p>
<p>The project files and code can be found <!-- raw HTML omitted --><strong>here.</strong><!-- raw HTML omitted --></p>
<hr>
<p>In part three, we will try to remotely control the smart power plug (turn it on and off).</p>
        </section>
        <div class="post-tags">
          
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/iamckn" rel="me" title="GitHub"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a><a class="border"></a><a class="soc" href="https://twitter.com/iamckn/" rel="me" title="Twitter"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#twitter" />
</svg></a><a class="border"></a></div>
  <div class="footer-info">
    2025  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
