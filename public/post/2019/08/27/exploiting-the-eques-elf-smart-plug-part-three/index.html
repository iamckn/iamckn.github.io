<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Exploiting the Eques Elf Smart Plug Part Three | The poetry of (in)security</title>
  <link rel = 'canonical' href = 'http://localhost:1313/post/2019/08/27/exploiting-the-eques-elf-smart-plug-part-three/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Exploiting the Eques Elf Smart Plug Part Three" />
<meta property="og:description" content="In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/2019/08/27/exploiting-the-eques-elf-smart-plug-part-three/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-27T15:53:09+03:00" />
<meta property="article:modified_time" content="2019-08-27T15:53:09+03:00" />


  <meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Exploiting the Eques Elf Smart Plug Part Three"/>
<meta name="twitter:description" content="In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post."/>

  
  
  
  <link rel="stylesheet" href="http://localhost:1313/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="http://localhost:1313/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="http://localhost:1313/">
  
    <div id="logo" style="background-image: url(http://localhost:1313/images/logo.png)"></div>
  
  <div id="title">
    <h1>The poetry of (in)security</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let&rsquo;s concentrate on that in this post.</p>
<p>We currently can:</p>
<ul>
<li>Decrypt messages between the phone, smart plug and server during plug discovery and port 9123 communication.</li>
<li>Discover any smart plug in the network and its details.</li>
<li>Communicate with ikonkek2.com server and query various details about a smart plug.</li>
</ul>
<p>We cannot:</p>
<ul>
<li>Remotely control the smart plug – Turn it on or off.</li>
</ul>
<h1 id="part-two-more-secret-keys-hooks-and-a-debugger">Part two: More secret keys, hooks and a debugger</h1>
<p>Turning the smart plug on or off happens over an xmpp chat (port 5222). The phone uses the username <code>phone_maceques@ikonkenk2.com</code> while the username of the smart plug is <code>device_mac@ikonkek2.com</code>.</p>
<p>The messages exchanged look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#e6db74">&#34;encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsN
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EwNWwDj1OYLY=
</span></span></span></code></pre></div><hr>
<p>Let’s continue our analysis the dynamic way. Let’s start by using Android’s logging capability - logcat.</p>
<p>When we turn the plug on, this is what we observe on logcat:</p>
<p><img src="/images/relayopen.png" alt="alt"></p>
<p>Clearer output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%f7HTEgDfZPLCyOqB4b2XZA<span style="color:#f92672">==</span>%relay to dc-4f-22-25-xx-xx@ikonkek2.com
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">==</span>Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@bba1c8b<span style="color:#f92672">=======</span>wan_device%dc-4f-22-25-xx-xx%nopassword%open%1563100747%rack
</span></span></code></pre></div><hr>
<p>When we turn the plug off</p>
<p><img src="/images/relayclose.png" alt="alt"></p>
<p>Clearer output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%1F6E1GyngNXKROGzGOmB4g<span style="color:#f92672">==</span>%relay to dc-4f-22-25-xx-xx@ikonkek2.com
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">==</span>Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@35ef906<span style="color:#f92672">=======</span>wan_device%dc-4f-22-25-xx-xx%nopassword%close%1563100818%rack
</span></span></code></pre></div><hr>
<p>We note that the function <code>sendEncodeMessage</code> is called when sending the XMPP message.</p>
<p>Let’s understand the process through dynamic analysis with Frida and GDB.</p>
<p>We start by running our frida-server on the phone, attach to the app and trace the “open” function:</p>
<p><code>frida-trace -i &quot;open&quot; -U -f &quot;com.eques.plug&quot;</code></p>
<p>We can see the app’s db is located at <strong>/data/user/0/com.eques.plug/databases/afinal.db</strong></p>
<p><img src="/images/db.png" alt="alt"></p>
<p>We can extract the db and open it with sqlitebrowser and see what is stored:</p>
<p><img src="/images/ikonke_device.png" alt="alt"></p>
<p>From the frida output we can also see the native library <code>libKonkeEncrypt.so</code> being opened when we turn the plug on or off.</p>
<p><img src="/images/konkeopen.png" alt="alt"></p>
<hr>
<p>To give us more control we’ll use the frida&rsquo;s scripting capability and its python bindings.</p>
<p>We can start by writing a script that prints out all the arguments and return values when the <code>sendEncodeMessage</code> function we discovered is called.</p>
<p>When we turn on the plug:</p>
<p><img src="/images/sendEncode_open.png" alt="alt"></p>
<p>When we turn off the plug:</p>
<p><img src="/images/sendEncode_close.png" alt="alt"></p>
<p>The output looks like what we had seen earlier on logcat with the word open or close replaced with some encrypted/encoded data.</p>
<p>Logcat message we had seen:</p>
<blockquote>
<p>E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<code>f7HTEgDfZPLCyOqB4b2XZA==</code>%relay to <a href="mailto:dc-4f-22-25-xx-xx@ikonkek2.com">dc-4f-22-25-xx-xx@ikonkek2.com</a></p>
</blockquote>
<p>What we see from hooking the SendEncodeMessage() function:</p>
<blockquote>
<p>wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%<code>open</code>%relay</p>
</blockquote>
<p>It looks like at some point, the words open (when turning on the plug) and close (when turning off the plug), have some encryption/encoding done to them.</p>
<hr>
<p>So let’s go back to the reversed apk and figure out what happens. What we discover is that a timestamp is inserted into the message then some encryption/encoding done.</p>
<p>This is done by the function <code>insertTimestampIntoMessage</code></p>
<p><img src="/images/timestamp.png" alt="alt"></p>
<p>Let’s write another frida script to intercept and log this function:</p>
<p><img src="/images/sendEncode_timestamp.png" alt="alt"></p>
<p>We can now confirm that indeed this is where the additional encryption/encoding is done. Also note <strong>arg3</strong> is set to true.</p>
<p>If we again look at the <code>insertTimestampIntoMessage</code> function Arg3 refers to the boolean value <strong>needNewEncode</strong>. When <strong>needNewEncode</strong> is set to true, the following operation is done:</p>
<p><code>cmd = EncryptUtil.newEncode(cmd.substring(1), deviceModel);</code></p>
<p>Let’s write another frida script to hook the <code>newEncode()</code> function.</p>
<p><img src="/images/newEncode.png" alt="alt"></p>
<p>Here we see a timestamp is added to the word open and an encrypted/encoded result returned.</p>
<hr>
<p>Back to the reversed apk code we can see that <code>newEncode()</code> uses <code>KonkeEncrypt().encryptCmdString</code> to encrypt the command:</p>
<p><img src="/images/encryptcmdstring.png" alt="alt"></p>
<p>Let’s write one more frida script to hook the <code>encryptCmdString() </code> function:</p>
<p><img src="/images/konke_encrypt.png" alt="alt"></p>
<p>This confirms, we&rsquo;re in the right path.</p>
<p>From there we discover that the function is loaded from a native library called <code>KonkeEncrypt</code>:</p>
<p><img src="/images/konkeencrypt.png" alt="alt"></p>
<p>The library is packaged with the apk in the <strong>lib/armeabi</strong> folder:</p>
<p><img src="/images/libKonke.png" alt="alt"></p>
<hr>
<p>Let&rsquo;s head back to Ghidra to see if we can figure out what exactly is happening during this encryption/encoding process.</p>
<p>The steps are basically the same as before:</p>
<p>We will open the <code>libKonkeEncrypt.so</code> file in Ghidra and then look for the <code>encryptCmdString()</code> function.</p>
<p><img src="/images/encryptcmdghidra.png" alt="alt"></p>
<p>We can get an idea of the flow from the function call graph:</p>
<p><img src="/images/encryptcmd_flow.png" alt="alt"></p>
<hr>
<p>Let’s see if we can see the library in action. For this we’re going to debug the <code>libKonkeEncrypt.so</code> library using GEF (<a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a>) – An enhanced version of GDB.</p>
<p>First we’re going  to copy an arm gdbserver to the phone in the <strong>/data/local/tmp/</strong> directory.</p>
<p>From an adb shell, we then start the gdbserver:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/data/local/tmp/gdbserver :1337 --attach <span style="color:#66d9ef">$(</span>ps | grep com.eques.plug | awk <span style="color:#e6db74">&#39;{print $2}&#39;</span><span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>Then we forward the remote port to our host using adb:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>adb forward tcp:1337 tcp:1337
</span></span></code></pre></div><p>Then we start GEF for remote debugging:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gef-remote :1337
</span></span></code></pre></div><p>GEF first reads symbols from the phone’s libraries:</p>
<p><img src="/images/gef-remote.png" alt="alt"></p>
<p>Once that is done, we let the app continue running:</p>
<p><img src="/images/gef-connected.png" alt="alt"></p>
<p>When we turn the plug on or off from the app, we can see the <code>libKonkeEncrypt.so</code> library gets opened by the app:</p>
<p><img src="/images/gef-konke.png" alt="alt"></p>
<p>By running the <code>info functions</code> gef command we can see the functions in our library of interest:</p>
<p><img src="/images/gef-konke-functions.png" alt="alt"></p>
<hr>
<p>From our earlier ghidra analysis, <code>aes_set_key()</code> sets the final encryption key in hex which is then used by <code>EncryptData256()</code> to encrypt the command. Let’s set breakpoints at these two function&rsquo;s addresses and then continue running the app:</p>
<p><img src="/images/gef-breaks.png" alt="alt"></p>
<p>When we hit the <code>EncryptData256()</code> break point we can inspect the registers, stack and function trace:</p>
<p><code>Registers</code>:</p>
<p><img src="/images/gef-encrypt-registers.png" alt="alt"></p>
<p><code>Stack</code>:</p>
<p><img src="/images/gef-encrypt-stack.png" alt="alt"></p>
<p><code>Function Trace</code>:</p>
<p><img src="/images/gef-encrypt-trace.png" alt="alt"></p>
<hr>
<p>We do the same when we hit the <code>aes_set_key()</code> breakpoint:</p>
<p><code>Registers</code>:</p>
<p><img src="/images/gef-aes-registers.png" alt="alt"></p>
<p><code>Stack</code>:</p>
<p><img src="/images/gef-aes-stack.png" alt="alt"></p>
<p><code>Function Trace</code>:</p>
<p><img src="/images/gef-aes-trace.png" alt="alt"></p>
<p>Stepping through the execution flow till the end, we eventually get our key stored in the r1 register:</p>
<p><img src="/images/gef-aes-r1.png" alt="alt"></p>
<p>The key is: <code>1c2f36737d07617a538f9f66659a2623</code>.</p>
<hr>
<p>We can convert it to hex and test it on some of our previously captured encrypted commands and confirm it is indeed the key:</p>
<p><img src="/images/konke_key_test.png" alt="alt"></p>
<p>And it works!</p>
<hr>
<p>Almost there, but not quite yet.</p>
<p>I tested the key against encrypted commands from other plugs, unfortunately it only worked for that one specific smart plug. We therefore need to figure out how the specific key for each smart power plug is generated.</p>
<p>After some more code analysis and debugging, the following is the function flow when <code>encryptCmdString()</code> is called:</p>
<blockquote>
<p><code>encryptCmdString()</code> calls <code>EncryptData256()</code></p>
<blockquote>
<p><code>EncryptData256()</code> calls <code>getKeyFromMethod2()</code></p>
<blockquote>
<p><code>getKeyFromMethod2()</code> calls <code>cmd_string_parse()</code>
<code>getKeyFromMethod2()</code> calls <code>generateKey1FromString()</code></p>
<blockquote>
<p><code>generateKey1FromString()</code> calls <code>generateKey2FromString()</code>
<code>getKeyFromMethod2()</code> then calls <code>dealKeyFromMethod2()</code>
<code>dealKeyFromMethod2()</code> then returns the key</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>We are going to concentrate on the <code>getKeyFromMethod2()</code> function.
First it calls <code>cmd_string_parse()</code>. I spent a lot of time figuring out what it does, only to realise that all it does is remove the hyphens from the mac address with some fancy use of C pointers. So <strong>dc-4f-22-25-xx-xx</strong> would result in <strong>dc4f2225xxxx</strong>.</p>
<p>Next let’s move to <code>generateKey1FromString()</code>. We can either go the static way using Ghidra or the dynamic way using GEF. Let&rsquo;s go with GEF.</p>
<p>We set breakpoints at <code>generateKey1FromString()</code> and <code>generateKey2FromString()</code> and then monitor the registers.</p>
<p><img src="/images/gef-remote-gen2.png" alt="alt"></p>
<p>After some debugging we get what looks like a key: <code>w5%45j!a,~j33in3lea^~rw2]ryxes8y</code> generated and stored in the r3 register.</p>
<p>With this discovery we can go back to Ghidra and continue analysing the <code>getKeyFromMethod2()</code> function.</p>
<p>We notice that some manipulation is done on this key using the smart power plug&rsquo;s password:</p>
<p><img src="/images/keygen_devpass_or.png" alt="alt"></p>
<p>What is happening is that the first 8 bytes of the key are bitwise OR’ed with the smart power plug&rsquo;s password. If the hex result of any of the bitwise ORs is 0x7e, it is replaced with 0x72. A quick python script can be written to reproduce this:</p>
<p><img src="/images/keygen_device_pass_script.png" alt="alt"></p>
<p>The result is then passed on to <code>dealKeyFromMethod2()</code> together with the parsed mac address (hyphens removed).</p>
<p>The return value is what should be our final key!</p>
<p>Analysing and cleaning up the code, I was able to figure out and reproduce the functionality.</p>
<p>The key has some of its bytes replaced with some bytes from the mac address of the smart power plug. This is done in the following manner:</p>
<ul>
<li>The 15th byte of the key is replaced with the 6th byte of the mac address</li>
<li>The 16th byte of the key is replaced with the 7th byte of the mac address</li>
<li>The 19th byte of the key is replaced with the 8th byte of the mac address</li>
<li>The 20th byte of the key is replaced with the 9th byte of the mac address</li>
<li>The 21st byte of the key is replaced with the 10th byte of the mac address</li>
<li>The 22nd byte of the key is replaced with the 11th byte of the mac address</li>
</ul>
<p>The md5sum is then calculated to create the final key.</p>
<hr>
<p>In summary, this is how the smart power plug specific key is generated:</p>
<ul>
<li><code>cmd_string_parse()</code> removes hyphens from the mac address.</li>
<li><code>generateKey1FromString()</code> and <code>generateKey2FromString()</code> are used to produce the key: <code>w5%45j!a,~j33in3lea^~rw2]ryxes8y</code>.</li>
<li><code>getKeyFromMethod2()</code> bitwise ORs the first 8 bytes of the key with the device
name/password.</li>
<li><code>dealKeyFromMethod2()</code> replaces some bytes of the key with some bytes of the mac
address, the md5sum of the result is the final device specific key.</li>
</ul>
<p>I tested this against more than one smart power plug with successful decryptions.</p>
<p>Now we have all we need to control any plug:</p>
<ul>
<li>The smart power plug’s mac address</li>
<li>The smart power plug’s password</li>
<li>The two encryption keys (one device specific and the other common to all smart power plugs)</li>
</ul>
<hr>
<p>With these details, we can use an xmpp client like pidgin to connect to the xmpp server (ikonkek2.com) using the username <code>&quot;phone macaddress&quot;eques@ikonkek2.com</code>.</p>
<p>Next we generate the smart plug specific encryption key.</p>
<p>We then use this key to encrypt either the <code>open&quot;timestamp&quot;</code> or <code>close&quot;timestamp&quot;</code> part of our command.</p>
<p>Finally we encrypt the full message using the common encryption key.</p>
<p>We will add the prefix <strong>encryption:</strong> to our encrypted message and send it to the device’s username <code>&quot;device macaddress@ikonkek2.com&quot;</code> over xmpp.</p>
<p>Note: The xmpp’s user passwords are just the same as the usernames.</p>
<hr>
<p>I automated the whole process of key generation, message formatting and encryption to output the message to be sent:</p>
<p><img src="/images/xmpp_commands.png" alt="alt"></p>
<p>Next I just copy the message and send it using pidgin:</p>
<p><img src="/images/xmpp_control.png" alt="alt"></p>
<p>And there we have it! We can now control the plug remotely even when it’s behind a NAT network.</p>
<p>The frida scripts and exploit code can be found <a href="https://github.com/iamckn/eques"><strong>here</strong></a>.</p>
<hr>
<p>In the final part, we will explore how this can be abused on a mass scale.</p>
  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2025  The poetry of (in)security 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/about">About</a></li>
         
        <li><a href="/tags">Tags</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
